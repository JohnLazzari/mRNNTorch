<!DOCTYPE html>

<html lang="en" data-content_root="../../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mrnntorch.analysis.fixed_points.fp_finder &#8212; mRNNTorch 0.0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../../_static/documentation_options.js?v=d45e8c67"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for mrnntorch.analysis.fixed_points.fp_finder</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">torch</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.fp</span><span class="w"> </span><span class="kn">import</span> <span class="n">FixedPointCollection</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mrnntorch.analysis.linear.linearization</span><span class="w"> </span><span class="kn">import</span> <span class="n">Linearization</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mrnntorch.mRNN</span><span class="w"> </span><span class="kn">import</span> <span class="n">mRNN</span>


<div class="viewcode-block" id="FixedPointFinder">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FixedPointFinder</span><span class="p">:</span>
    <span class="n">_default_hps</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;lr_init&quot;</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="s2">&quot;lr_patience&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="s2">&quot;lr_factor&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
        <span class="s2">&quot;lr_cooldown&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;tol_q&quot;</span><span class="p">:</span> <span class="mf">1e-12</span><span class="p">,</span>
        <span class="s2">&quot;tol_dq&quot;</span><span class="p">:</span> <span class="mf">1e-20</span><span class="p">,</span>
        <span class="s2">&quot;max_iters&quot;</span><span class="p">:</span> <span class="mi">5000</span><span class="p">,</span>
        <span class="s2">&quot;do_rerun_q_outliers&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;outlier_q_scale&quot;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
        <span class="s2">&quot;do_exclude_distance_outliers&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;outlier_distance_scale&quot;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>
        <span class="s2">&quot;tol_unique&quot;</span><span class="p">:</span> <span class="mf">1e-3</span><span class="p">,</span>
        <span class="s2">&quot;max_n_unique&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
        <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="s2">&quot;random_seed&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;verbose&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;super_verbose&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="s2">&quot;n_iters_per_print_update&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
        <span class="s2">&quot;batch_first&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">}</span>

<div class="viewcode-block" id="FixedPointFinder.default_hps">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.default_hps">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">default_hps</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a deep copy of the default hyperparameters dict.</span>

<span class="sd">        The deep copy protects against external updates to the defaults, which</span>
<span class="sd">        in turn protects against unintended interactions with the hashing done</span>
<span class="sd">        by the Hyperparameters class.</span>

<span class="sd">        Args:</span>
<span class="sd">            None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict of hyperparameters.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_default_hps</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mrnn</span><span class="p">:</span> <span class="n">mRNN</span><span class="p">,</span>
        <span class="n">lr_init</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;lr_init&quot;</span><span class="p">],</span>
        <span class="n">lr_patience</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;lr_patience&quot;</span><span class="p">],</span>
        <span class="n">lr_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;lr_factor&quot;</span><span class="p">],</span>
        <span class="n">lr_cooldown</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;lr_cooldown&quot;</span><span class="p">],</span>
        <span class="n">tol_q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;tol_q&quot;</span><span class="p">],</span>
        <span class="n">tol_dq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;tol_dq&quot;</span><span class="p">],</span>
        <span class="n">max_iters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;max_iters&quot;</span><span class="p">],</span>
        <span class="n">do_rerun_q_outliers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;do_rerun_q_outliers&quot;</span><span class="p">],</span>
        <span class="n">outlier_q_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;outlier_q_scale&quot;</span><span class="p">],</span>
        <span class="n">do_exclude_distance_outliers</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span>
            <span class="s2">&quot;do_exclude_distance_outliers&quot;</span>
        <span class="p">],</span>
        <span class="n">outlier_distance_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;outlier_distance_scale&quot;</span><span class="p">],</span>
        <span class="n">tol_unique</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;tol_unique&quot;</span><span class="p">],</span>
        <span class="n">max_n_unique</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;max_n_unique&quot;</span><span class="p">],</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;dtype&quot;</span><span class="p">],</span>
        <span class="n">random_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;random_seed&quot;</span><span class="p">],</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;verbose&quot;</span><span class="p">],</span>
        <span class="n">super_verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;super_verbose&quot;</span><span class="p">],</span>
        <span class="n">n_iters_per_print_update</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">_default_hps</span><span class="p">[</span><span class="s2">&quot;n_iters_per_print_update&quot;</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a FixedPointFinder object.</span>

<span class="sd">        Optimization terminates once every initialization satisfies one or</span>
<span class="sd">        both of the following criteria:</span>
<span class="sd">            1. q &lt; tol_q</span>
<span class="sd">            2. dq &lt; tol_dq * learning_rate</span>

<span class="sd">        Args:</span>
<span class="sd">            rnn_cell: A Pytorch RNN</span>

<span class="sd">            tol_q (optional): A positive scalar specifying the optimization</span>
<span class="sd">            termination criteria on each q-value. Default: 1e-12.</span>

<span class="sd">            tol_dq (optional): A positive scalar specifying the optimization</span>
<span class="sd">            termination criteria on the improvement of each q-value (i.e.,</span>
<span class="sd">            &quot;dq&quot;) from one optimization iteration to the next. Default: 1e-20.</span>

<span class="sd">            max_iters (optional): A non-negative integer specifying the</span>
<span class="sd">            maximum number of gradient descent iterations allowed.</span>
<span class="sd">            Optimization terminates upon reaching this iteration count, even</span>
<span class="sd">            if &#39;tol&#39; has not been reached. Default: 5000.</span>

<span class="sd">            do_rerun_q_outliers (optional): A bool indicating whether or not</span>
<span class="sd">            to run additional optimization iterations on putative outlier</span>
<span class="sd">            states, identified as states with large q values relative to the</span>
<span class="sd">            median q value across all identified fixed points (i.e., after</span>
<span class="sd">            the initial optimization ran to termination). These additional</span>
<span class="sd">            optimizations are run sequentially (even if method is &#39;joint&#39;).</span>
<span class="sd">            Default: False.</span>

<span class="sd">            outlier_q_scale (optional): A positive float specifying the q</span>
<span class="sd">            value for putative outlier fixed points, relative to the median q</span>
<span class="sd">            value across all identified fixed points. Default: 10.</span>

<span class="sd">            do_exclude_distance_outliers (optional): A bool indicating</span>
<span class="sd">            whether or not to discard states that are far away from the set</span>
<span class="sd">            of initial states, as measured by a normalized euclidean</span>
<span class="sd">            distance. If true, states are evaluated and possibly discarded</span>
<span class="sd">            after the initial optimization runs to termination.</span>
<span class="sd">            Default: True.</span>

<span class="sd">            outlier_distance_scale (optional): A positive float specifying a</span>
<span class="sd">            normalized distance cutoff used to exclude distance outliers. All</span>
<span class="sd">            distances are calculated relative to the centroid of the</span>
<span class="sd">            initial_states and are normalized by the average distance-to-</span>
<span class="sd">            centroid of the initial_states. Default: 10.</span>

<span class="sd">            tol_unique (optional): A positive scalar specifying the numerical</span>
<span class="sd">            precision required to label two fixed points as being unique from</span>
<span class="sd">            one another. Two fixed points will be considered unique if they</span>
<span class="sd">            differ by this amount (or more) along any dimension. This</span>
<span class="sd">            tolerance is used to discard numerically similar fixed points.</span>
<span class="sd">            Default: 1e-3.</span>

<span class="sd">            max_n_unique (optional): A positive integer indicating the max</span>
<span class="sd">            number of unique fixed points to keep. If the number of unique</span>
<span class="sd">            fixed points identified exceeds this value, points are randomly</span>
<span class="sd">            dropped. Default: np.inf.</span>

<span class="sd">            dtype: string indicating the data type to use for all numerical ops</span>
<span class="sd">            and objects. Default: &#39;float32&#39;</span>

<span class="sd">            random_seed: Seed for numpy random number generator. Default: 0.</span>

<span class="sd">            verbose (optional): A bool indicating whether to print high-level</span>
<span class="sd">            status updates. Default: True.</span>

<span class="sd">            super_verbose (optional): A bool indicating whether or not to</span>
<span class="sd">            print per-iteration updates during each optimization. Default:</span>
<span class="sd">            False.</span>

<span class="sd">            n_iters_per_print_update (optional): An int specifying how often</span>
<span class="sd">            to print updates during the fixed point optimizations. Default:</span>
<span class="sd">            100.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">np_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">device</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">mrnn</span><span class="o">.</span><span class="n">parameters</span><span class="p">())</span><span class="o">.</span><span class="n">device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">torch_dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">torch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Make random sequences reproducible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_seed</span> <span class="o">=</span> <span class="n">random_seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="c1"># *********************************************************************</span>
        <span class="c1"># Optimization hyperparameters ****************************************</span>
        <span class="c1"># *********************************************************************</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span> <span class="o">=</span> <span class="n">mrnn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_init</span> <span class="o">=</span> <span class="n">lr_init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_patience</span> <span class="o">=</span> <span class="n">lr_patience</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_factor</span> <span class="o">=</span> <span class="n">lr_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lr_cooldown</span> <span class="o">=</span> <span class="n">lr_cooldown</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_q</span> <span class="o">=</span> <span class="n">tol_q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_dq</span> <span class="o">=</span> <span class="n">tol_dq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iters</span> <span class="o">=</span> <span class="n">max_iters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_rerun_q_outliers</span> <span class="o">=</span> <span class="n">do_rerun_q_outliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlier_q_scale</span> <span class="o">=</span> <span class="n">outlier_q_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_exclude_distance_outliers</span> <span class="o">=</span> <span class="n">do_exclude_distance_outliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outlier_distance_scale</span> <span class="o">=</span> <span class="n">outlier_distance_scale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tol_unique</span> <span class="o">=</span> <span class="n">tol_unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_n_unique</span> <span class="o">=</span> <span class="n">max_n_unique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_verbose</span> <span class="o">=</span> <span class="n">super_verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iters_per_print_update</span> <span class="o">=</span> <span class="n">n_iters_per_print_update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">batch_first</span>

    <span class="c1"># *************************************************************************</span>
    <span class="c1"># Primary exposed functions ***********************************************</span>
    <span class="c1"># *************************************************************************</span>

<div class="viewcode-block" id="FixedPointFinder.sample_states">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.sample_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state_traj</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">n_inits</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">noise_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">exclude_zero_tensors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Draws random samples from trajectories of the RNN state. Samples</span>
<span class="sd">        can optionally be corrupted by independent and identically distributed</span>
<span class="sd">        (IID) Gaussian noise. These samples are intended to be used as initial</span>
<span class="sd">        states for fixed point optimizations.</span>

<span class="sd">        Args:</span>
<span class="sd">            state_traj: 1D or ND tensor containing</span>
<span class="sd">            example trajectories of the RNN state.</span>

<span class="sd">            n_inits: int specifying the number of sampled states to return.</span>

<span class="sd">            noise_scale (optional): non-negative float specifying the standard</span>
<span class="sd">            deviation of IID Gaussian noise samples added to the sampled</span>
<span class="sd">            states.</span>

<span class="sd">            exclude_zero_tensors (bool, optional): whether to exclude zeros</span>
<span class="sd">            tensors that may be in state_traj</span>

<span class="sd">        Returns:</span>
<span class="sd">            initial_states: Sampled RNN states as a [n_inits x n_states] tensor</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if noise_scale is negative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state_traj</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">state_traj</span> <span class="o">=</span> <span class="n">state_traj</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get the batch shape of state trajectory, assumes -1 is state dim</span>
        <span class="n">flat_state_traj</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">state_traj</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_zero_tensors</span><span class="p">:</span>
            <span class="n">non_zero_rows</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">flat_state_traj</span><span class="p">,</span> <span class="n">as_tuple</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">non_zero_rows</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">non_zero_rows</span><span class="p">)</span>
            <span class="n">flat_state_traj</span> <span class="o">=</span> <span class="n">flat_state_traj</span><span class="p">[</span><span class="n">non_zero_rows</span><span class="p">]</span>

        <span class="n">rand_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">high</span><span class="o">=</span><span class="n">flat_state_traj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n_inits</span><span class="p">,))</span>
        <span class="n">states</span> <span class="o">=</span> <span class="n">flat_state_traj</span><span class="p">[</span><span class="n">rand_indices</span><span class="p">]</span>

        <span class="c1"># Add IID Gaussian noise to the sampled states</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_gaussian_noise</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">noise_scale</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">states</span><span class="p">)),</span> <span class="p">(</span>
            <span class="s2">&quot;Detected NaNs in sampled states. Check state_traj and valid_bxt.&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">states</span></div>


<div class="viewcode-block" id="FixedPointFinder.find_fixed_points">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.find_fixed_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_fixed_points</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_states</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ext_inputs</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">stim_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_rec</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_rounds_q_opt</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">FixedPointCollection</span><span class="p">,</span> <span class="n">FixedPointCollection</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds RNN fixed points and the Jacobians at the fixed points.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_states: Tensor specifying the initial</span>
<span class="sd">            states of the RNN, from which the optimization will search for</span>
<span class="sd">            fixed points.</span>

<span class="sd">            ext_inputs: external inputs to the RNN</span>

<span class="sd">            stim_inp: Additional stimulus input to the network</span>

<span class="sd">            W_rec: Fixed weight matrix to replace self.mrnn.W_rec in forward</span>
<span class="sd">            pass</span>

<span class="sd">            W_rec: Fixed weight matrix to replace self.mrnn.W_inp in forward</span>
<span class="sd">            pass</span>

<span class="sd">            n_rounds_q_opt: Number of rounds to run extra iterations on q</span>
<span class="sd">            outliers</span>

<span class="sd">        Returns:</span>
<span class="sd">            unique_fps: A FixedPoints object containing the set of unique</span>
<span class="sd">            fixed points after optimizing from all initial_states. Two fixed</span>
<span class="sd">            points are considered unique if all absolute element-wise</span>
<span class="sd">            differences are less than tol_unique AND the corresponding inputs</span>
<span class="sd">            are unique following the same criteria. See FixedPoints.py for</span>
<span class="sd">            additional detail.</span>

<span class="sd">            all_fps: A FixedPoints object containing the likely redundant set</span>
<span class="sd">            of fixed points (and associated metadata) resulting from ALL</span>
<span class="sd">            initializations in initial_states (i.e., the full set of fixed</span>
<span class="sd">            points before filtering out putative duplicates to yield</span>
<span class="sd">            unique_fps).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp_optimization</span><span class="p">(</span>
            <span class="n">initial_states</span><span class="p">,</span>
            <span class="n">ext_inputs</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span>
            <span class="n">stim_inp</span><span class="o">=</span><span class="n">stim_inp</span><span class="p">,</span>
            <span class="n">W_rec</span><span class="o">=</span><span class="n">W_rec</span><span class="p">,</span>
            <span class="n">W_inp</span><span class="o">=</span><span class="n">W_inp</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Filter out duplicates after from the first optimization round</span>
        <span class="n">unique_fps</span> <span class="o">=</span> <span class="n">all_fps</span><span class="o">.</span><span class="n">get_unique</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Identified </span><span class="si">%d</span><span class="s2"> unique fixed points.&quot;</span> <span class="o">%</span> <span class="n">unique_fps</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_exclude_distance_outliers</span><span class="p">:</span>
            <span class="n">unique_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exclude_distance_outliers</span><span class="p">(</span><span class="n">unique_fps</span><span class="p">,</span> <span class="n">initial_states</span><span class="p">)</span>

        <span class="c1"># Optionally run additional optimization iterations on identified</span>
        <span class="c1"># fixed points with q values on the large side of the q-distribution.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_rerun_q_outliers</span><span class="p">:</span>
            <span class="n">unique_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_run_additional_iterations_on_outliers</span><span class="p">(</span>
                <span class="n">unique_fps</span><span class="p">,</span>
                <span class="n">stim_inp</span><span class="o">=</span><span class="n">stim_inp</span><span class="p">,</span>
                <span class="n">W_rec</span><span class="o">=</span><span class="n">W_rec</span><span class="p">,</span>
                <span class="n">W_inp</span><span class="o">=</span><span class="n">W_inp</span><span class="p">,</span>
                <span class="n">n_rounds</span><span class="o">=</span><span class="n">n_rounds_q_opt</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Filter out duplicates after from the second optimization round</span>
            <span class="n">unique_fps</span> <span class="o">=</span> <span class="n">unique_fps</span><span class="o">.</span><span class="n">get_unique</span><span class="p">()</span>

        <span class="c1"># Optionally subselect from the unique fixed points (e.g., for</span>
        <span class="c1"># computational savings when not all are needed.)</span>
        <span class="k">if</span> <span class="n">unique_fps</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_unique</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Randomly selecting </span><span class="si">%d</span><span class="s2"> unique &quot;</span>
                <span class="s2">&quot;fixed points to keep.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_unique</span>
            <span class="p">)</span>
            <span class="n">max_n_unique</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_n_unique</span><span class="p">)</span>
            <span class="n">idx_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">unique_fps</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">max_n_unique</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">unique_fps</span> <span class="o">=</span> <span class="n">unique_fps</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Fixed point finding complete.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unique_fps</span><span class="p">,</span> <span class="n">all_fps</span></div>


    <span class="c1"># *************************************************************************</span>
    <span class="c1"># Helper functions ********************************************************</span>
    <span class="c1"># *************************************************************************</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_gaussian_noise</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">noise_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds IID Gaussian noise to Numpy data.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: Tensor</span>

<span class="sd">            noise_scale: (Optional) non-negative scalar indicating the</span>
<span class="sd">            standard deviation of the Gaussian noise samples to be generated.</span>
<span class="sd">            Default: 0.0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor matching shape of data with noise added</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError if noise_scale is negative.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add IID Gaussian noise</span>
        <span class="k">if</span> <span class="n">noise_scale</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>  <span class="c1"># no noise to add</span>
        <span class="k">if</span> <span class="n">noise_scale</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span> <span class="o">+</span> <span class="n">noise_scale</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">noise_scale</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;noise_scale must be non-negative, but was </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">noise_scale</span>
            <span class="p">)</span>

<div class="viewcode-block" id="FixedPointFinder.identify_q_outliers">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.identify_q_outliers">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">identify_q_outliers</span><span class="p">(</span><span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span> <span class="n">q_thresh</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify fixed points with optimized q values that exceed a</span>
<span class="sd">        specified threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            fps: A FixedPoints object containing optimized fixed points and</span>
<span class="sd">            associated metadata.</span>

<span class="sd">            q_thresh: A scalar float indicating the threshold on fixed</span>
<span class="sd">            points&#39; q values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tensor containing the indices into fps corresponding to</span>
<span class="sd">            the fixed points with q values exceeding the threshold.</span>

<span class="sd">        Usage:</span>
<span class="sd">            idx = identify_q_outliers(fps, q_thresh)</span>
<span class="sd">            outlier_fps = fps[idx]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fps</span><span class="o">.</span><span class="n">qstar</span> <span class="o">&gt;</span> <span class="n">q_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FixedPointFinder.identify_q_non_outliers">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.identify_q_non_outliers">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">identify_q_non_outliers</span><span class="p">(</span>
        <span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span> <span class="n">q_thresh</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify fixed points with optimized q values that do not exceed a</span>
<span class="sd">        specified threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            fps: A FixedPoints object containing optimized fixed points and</span>
<span class="sd">            associated metadata.</span>

<span class="sd">            q_thresh: A scalar float indicating the threshold on fixed points&#39;</span>
<span class="sd">            q values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tensor containing the indices into fps corresponding to the</span>
<span class="sd">            fixed points with q values that do not exceed the threshold.</span>

<span class="sd">        Usage:</span>
<span class="sd">            idx = identify_q_non_outliers(fps, q_thresh)</span>
<span class="sd">            non_outlier_fps = fps[idx]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fps</span><span class="o">.</span><span class="n">qstar</span> <span class="o">&lt;=</span> <span class="n">q_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="FixedPointFinder.get_init_non_distance_outliers">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.get_init_non_distance_outliers">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_init_non_distance_outliers</span><span class="p">(</span>
        <span class="n">initial_states</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get initial states that are far from centroid based on threshold.</span>
<span class="sd">        Args:</span>
<span class="sd">            initial_states (Tensor): initial states of fp optimization [n, state_dim]</span>
<span class="sd">            dist_thresh (float): Threshold from initial states which is far.</span>
<span class="sd">        Returns:</span>
<span class="sd">            init_non_outlier_idx (Tensor): indices to initial_states tensor inside threshold</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Centroid of initial_states, shape (n_states,)</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Distance of each initial state from the centroid, shape (n,)</span>
        <span class="n">init_dists</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">initial_states</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">avg_init_dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">init_dists</span><span class="p">)</span>

        <span class="c1"># Normalized distances of initial states to the centroid, shape: (n,)</span>
        <span class="n">scaled_init_dists</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">init_dists</span><span class="p">,</span> <span class="n">avg_init_dist</span><span class="p">)</span>

        <span class="n">init_non_outlier_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scaled_init_dists</span> <span class="o">&lt;</span> <span class="n">dist_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">init_non_outlier_idx</span></div>


<div class="viewcode-block" id="FixedPointFinder.get_fp_non_distance_outliers">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.get_fp_non_distance_outliers">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_fp_non_distance_outliers</span><span class="p">(</span>
        <span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span> <span class="n">initial_states</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dist_thresh</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get fixed points that are far from initial states based on threshold.</span>
<span class="sd">        Args:</span>
<span class="sd">            fps (FixedPointCollection): fps discovered [n, state_dim]</span>
<span class="sd">            initial_states (Tensor): initial states of optimization [n, state_dim]</span>
<span class="sd">            dist_thresh (float): threshold at which fixed points are considered far</span>
<span class="sd">        Returns:</span>
<span class="sd">            fsp_non_outlier_distance (Tensor): indices to fps object that are not far</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Centroid of initial_states, shape (n_states,)</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Distance of each initial state from the centroid, shape (n,)</span>
        <span class="n">init_dists</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">initial_states</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">avg_init_dist</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">init_dists</span><span class="p">)</span>

        <span class="c1"># Distance of each FP from the initial_states centroid</span>
        <span class="n">fps_dists</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fps</span><span class="o">.</span><span class="n">xstar</span> <span class="o">-</span> <span class="n">centroid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Normalized</span>
        <span class="n">scaled_fps_dists</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">fps_dists</span><span class="p">,</span> <span class="n">avg_init_dist</span><span class="p">)</span>

        <span class="n">fps_non_outlier_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scaled_fps_dists</span> <span class="o">&lt;</span> <span class="n">dist_thresh</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">fps_non_outlier_idx</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_exclude_distance_outliers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span> <span class="n">initial_states</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FixedPointCollection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes putative distance outliers from a set of fixed points.</span>
<span class="sd">        See docstring for identify_distance_non_outliers(...).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx_keep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fp_non_distance_outliers</span><span class="p">(</span>
            <span class="n">fps</span><span class="p">,</span> <span class="n">initial_states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_distance_scale</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">fps</span><span class="p">[</span><span class="n">idx_keep</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_run_additional_iterations_on_outliers</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span>
        <span class="n">stim_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_rec</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_rounds</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FixedPointCollection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Detects outlier states with respect to the q function and runs</span>
<span class="sd">        additional optimization iterations on those states This should only be</span>
<span class="sd">        used after calling either _run_joint_optimization or</span>
<span class="sd">        _run_sequential_optimizations.</span>

<span class="sd">        Args:</span>
<span class="sd">            fps: A FixedPoints object containing (partially) optimized</span>
<span class="sd">            fixed points and associated metadata.</span>

<span class="sd">            stim_inp: additional stimulus to give network during optimization</span>

<span class="sd">            W_rec: replaces self.mrnn.W_rec during forward pass</span>

<span class="sd">            W_inp: replaces self.mrnn.W_inp during forward pass</span>

<span class="sd">        Returns:</span>
<span class="sd">            A FixedPoints object containing the further-optimized fixed points</span>
<span class="sd">            and associated metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>

<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Known issue:</span>
<span class="sd">            Additional iterations do not always reduce q! This may have to do</span>
<span class="sd">            with learning rate schedules restarting from values that are too</span>
<span class="sd">            large.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">outlier_min_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">fps</span><span class="o">.</span><span class="n">qstar</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">outlier_q_scale</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">perform_outlier_optimization</span><span class="p">(</span>
            <span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FixedPointCollection</span><span class="p">:</span>
            <span class="n">idx_outliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_q_outliers</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="n">outlier_min_q</span><span class="p">)</span>

            <span class="n">outlier_fps</span> <span class="o">=</span> <span class="n">fps</span><span class="p">[</span><span class="n">idx_outliers</span><span class="p">]</span>
            <span class="n">n_prev_iters</span> <span class="o">=</span> <span class="n">outlier_fps</span><span class="o">.</span><span class="n">n_iters</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="n">outlier_fps</span><span class="o">.</span><span class="n">inputs</span>
            <span class="n">initial_states</span> <span class="o">=</span> <span class="n">outlier_fps</span><span class="o">.</span><span class="n">xstar</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Performing another round of &quot;</span>
                <span class="s2">&quot;joint optimization, &quot;</span>
                <span class="s2">&quot;over outlier states only.&quot;</span>
            <span class="p">)</span>

            <span class="n">updated_outlier_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fp_optimization</span><span class="p">(</span>
                <span class="n">initial_states</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">stim_inp</span><span class="o">=</span><span class="n">stim_inp</span><span class="p">,</span> <span class="n">W_rec</span><span class="o">=</span><span class="n">W_rec</span><span class="p">,</span> <span class="n">W_inp</span><span class="o">=</span><span class="n">W_inp</span>
            <span class="p">)</span>

            <span class="n">updated_outlier_fps</span><span class="o">.</span><span class="n">n_iters</span> <span class="o">+=</span> <span class="n">n_prev_iters</span>
            <span class="n">fps</span><span class="p">[</span><span class="n">idx_outliers</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_outlier_fps</span>

            <span class="k">return</span> <span class="n">fps</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">outlier_update</span><span class="p">(</span><span class="n">fps</span><span class="p">:</span> <span class="n">FixedPointCollection</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">idx_outliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identify_q_outliers</span><span class="p">(</span><span class="n">fps</span><span class="p">,</span> <span class="n">outlier_min_q</span><span class="p">)</span>
            <span class="n">n_outliers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_outliers</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">Detected </span><span class="si">%d</span><span class="s2"> putative outliers &quot;</span>
                <span class="s2">&quot;(q&gt;</span><span class="si">%.2e</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_outliers</span><span class="p">,</span> <span class="n">outlier_min_q</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">idx_outliers</span>

        <span class="n">idx_outliers</span> <span class="o">=</span> <span class="n">outlier_update</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_outliers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fps</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
            <span class="n">fps</span> <span class="o">=</span> <span class="n">perform_outlier_optimization</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
            <span class="n">idx_outliers</span> <span class="o">=</span> <span class="n">outlier_update</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_outliers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fps</span>

        <span class="k">return</span> <span class="n">fps</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_print_if_verbose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_print_iter_update</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">iter_count</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">t_start</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">dq</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">lr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">is_final</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">t_elapsed</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">t_start</span>
        <span class="n">avg_iter_time</span> <span class="o">=</span> <span class="n">t_elapsed</span> <span class="o">/</span> <span class="n">iter_count</span>

        <span class="k">if</span> <span class="n">is_final</span><span class="p">:</span>
            <span class="n">delimiter</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\t\t</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t\t</span><span class="si">%d</span><span class="s2"> iters</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delimiter</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Iter: </span><span class="si">%d%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iter_count</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;q = </span><span class="si">%.2e%s</span><span class="s2">dq = </span><span class="si">%.2e%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">dq</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mean_q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
            <span class="n">std_q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

            <span class="n">mean_dq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span>
            <span class="n">std_dq</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dq</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;q = </span><span class="si">%.2e</span><span class="s2"> +/- </span><span class="si">%.2e%s</span><span class="s2">&quot;</span>
                <span class="s2">&quot;dq = </span><span class="si">%.2e</span><span class="s2"> +/- </span><span class="si">%.2e%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">mean_q</span><span class="p">,</span> <span class="n">std_q</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">mean_dq</span><span class="p">,</span> <span class="n">std_dq</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">),</span>
                <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;learning rate = </span><span class="si">%.2e%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lr</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;avg iter time = </span><span class="si">%.2e</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="n">avg_iter_time</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fp_optimization</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">initial_states</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="n">ext_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">stim_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_rec</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">W_inp</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FixedPointCollection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds multiple fixed points via a joint optimization over multiple</span>
<span class="sd">        state vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">            initial_states: Tensor specifying the initial</span>
<span class="sd">            states of the RNN, from which the optimization will search for</span>
<span class="sd">            fixed points.</span>

<span class="sd">            ext_inp: Tensor specifying a set of constant</span>
<span class="sd">            inputs into the RNN.</span>

<span class="sd">            stim_inp: Tensor specifying additional stimulus to the network</span>

<span class="sd">            W_rec: replaces self.mrnn.W_rec in forward</span>

<span class="sd">            W_inp: replaces self.mrnn.W_inp in forward</span>

<span class="sd">        Returns:</span>
<span class="sd">            fps: A FixedPoints object containing the optimized fixed points</span>
<span class="sd">            and associated metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get batch and time dims</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_first</span><span class="p">:</span>
            <span class="n">TIME_DIM</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">TIME_DIM</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">initial_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast_nxd</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">tile_n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get batch size of states</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">initial_states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Broadcast external input to [n, 1, d]</span>
        <span class="n">ext_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast_nxd</span><span class="p">(</span><span class="n">ext_inp</span><span class="p">,</span> <span class="n">tile_n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">ext_inp</span> <span class="o">=</span> <span class="n">ext_inp</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">TIME_DIM</span><span class="p">)</span>

        <span class="c1"># Broadcast stimulus input to [n, 1, d]</span>
        <span class="k">if</span> <span class="n">stim_inp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stim_inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_broadcast_nxd</span><span class="p">(</span><span class="n">stim_inp</span><span class="p">,</span> <span class="n">tile_n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">stim_inp</span> <span class="o">=</span> <span class="n">stim_inp</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">TIME_DIM</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stim_inp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">stim_inp</span> <span class="o">=</span> <span class="n">stim_inp</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch_dtype</span><span class="p">)</span>
            <span class="n">stim_inp</span> <span class="o">=</span> <span class="n">stim_inp</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="c1"># assert the correct batch shapes</span>
        <span class="k">assert</span> <span class="n">ext_inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">stim_inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">initial_states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Searching for fixed points from </span><span class="si">%d</span><span class="s2"> initial states.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span>
        <span class="p">)</span>

        <span class="c1"># Ensure that fixed point optimization does not alter RNN parameters.</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Freezing model parameters so model is not affected by fixed point optimization.&quot;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">p</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Finding fixed points via joint optimization.&quot;</span><span class="p">)</span>
        <span class="c1"># initialize args to include all regions if empty</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">region_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">ext_inp</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Gather all of the regions to concatenate during training</span>
        <span class="c1"># Get them region by region for proper optimization</span>
        <span class="n">region_tensor_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">region_to_opt_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">region_dict</span><span class="p">):</span>
            <span class="n">act</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">get_region_activity</span><span class="p">(</span><span class="n">initial_states</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>
            <span class="n">region_tensor_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">act</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">act</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">region_to_opt_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="n">init_lr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lr_init</span>
        <span class="n">optimizer</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">Adam</span><span class="p">(</span>
            <span class="p">[</span><span class="n">region_tensor_list</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">region_to_opt_idx</span><span class="p">],</span> <span class="n">lr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lr_init</span>
        <span class="p">)</span>

        <span class="n">scheduler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">ReduceLROnPlateau</span><span class="p">(</span>
            <span class="n">optimizer</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cooldown</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1e-10</span>
        <span class="p">)</span>

        <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">iter_learning_rate</span> <span class="o">=</span> <span class="n">init_lr</span>
        <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">q_prev_b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">),</span> <span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">W_rec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">W_rec</span> <span class="o">=</span> <span class="n">W_rec</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">W_inp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">W_inp</span> <span class="o">=</span> <span class="n">W_inp</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">region_tensor_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">region_tensor_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>

            <span class="n">_</span><span class="p">,</span> <span class="n">F_x_1xbxd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="p">(</span>
                <span class="n">ext_inp</span><span class="p">,</span>
                <span class="n">x</span><span class="p">,</span>
                <span class="n">h</span><span class="p">,</span>
                <span class="n">stim_inp</span><span class="p">,</span>
                <span class="n">noise</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">W_rec</span><span class="o">=</span><span class="n">W_rec</span><span class="p">,</span>
                <span class="n">W_inp</span><span class="o">=</span><span class="n">W_inp</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">F_x_1xbxd</span> <span class="o">=</span> <span class="n">F_x_1xbxd</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">TIME_DIM</span><span class="p">)</span>

            <span class="n">h_prev</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">h_next</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">h_prev</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">get_region_activity</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">region</span><span class="p">))</span>
                <span class="n">h_next</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="o">.</span><span class="n">get_region_activity</span><span class="p">(</span><span class="n">F_x_1xbxd</span><span class="p">,</span> <span class="n">region</span><span class="p">))</span>
            <span class="n">h_prev</span><span class="p">,</span> <span class="n">h_next</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">h_prev</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">h_next</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">dx_bxd</span> <span class="o">=</span> <span class="n">h_prev</span> <span class="o">-</span> <span class="n">h_next</span>
            <span class="n">q_b</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">dx_bxd</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">q_scalar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">q_b</span><span class="p">)</span>
            <span class="n">dq_b</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">q_b</span> <span class="o">-</span> <span class="n">q_prev_b</span><span class="p">)</span>

            <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
            <span class="n">q_scalar</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

            <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
            <span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">metrics</span><span class="o">=</span><span class="n">q_scalar</span><span class="p">)</span>

            <span class="n">iter_learning_rate</span> <span class="o">=</span> <span class="n">scheduler</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()[</span><span class="s2">&quot;_last_lr&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">ev_q_b</span> <span class="o">=</span> <span class="n">q_b</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
            <span class="n">ev_dq_b</span> <span class="o">=</span> <span class="n">dq_b</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">super_verbose</span>
                <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">iter_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iters_per_print_update</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print_iter_update</span><span class="p">(</span>
                    <span class="n">iter_count</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">ev_q_b</span><span class="p">,</span> <span class="n">ev_dq_b</span><span class="p">,</span> <span class="n">iter_learning_rate</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">iter_count</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span>
                    <span class="n">ev_dq_b</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_dq</span> <span class="o">*</span> <span class="n">iter_learning_rate</span><span class="p">,</span> <span class="n">ev_q_b</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tol_q</span>
                <span class="p">)</span>
            <span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Here dq is scaled by the learning rate. Otherwise very</span>
<span class="sd">                small steps due to very small learning rates would spuriously</span>
<span class="sd">                indicate convergence. This scaling is roughly equivalent to</span>
<span class="sd">                measuring the gradient norm.&quot;&quot;&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Optimization complete to desired tolerance.&quot;</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">iter_count</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iters</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_print_if_verbose</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">Maximum iteration count reached. Terminating.&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>

            <span class="n">q_prev_b</span> <span class="o">=</span> <span class="n">q_b</span>
            <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_iter_update</span><span class="p">(</span>
                <span class="n">iter_count</span><span class="p">,</span> <span class="n">t_start</span><span class="p">,</span> <span class="n">ev_q_b</span><span class="p">,</span> <span class="n">ev_dq_b</span><span class="p">,</span> <span class="n">iter_learning_rate</span><span class="p">,</span> <span class="n">is_final</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="c1"># remove extra dims</span>
        <span class="c1"># For now make the fixed point include all regions</span>
        <span class="n">full_fp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">region_tensor_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xstar</span> <span class="o">=</span> <span class="n">full_fp</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="n">F_xstar</span> <span class="o">=</span> <span class="n">F_x_1xbxd</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

        <span class="c1"># Indicate same n_iters for each initialization (i.e., joint optimization)</span>
        <span class="n">n_iters</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">iter_count</span><span class="p">]),</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="n">F_xstar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>
        <span class="n">inputs_bxd</span> <span class="o">=</span> <span class="n">ext_inp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">TIME_DIM</span><span class="p">)</span>

        <span class="n">fps</span> <span class="o">=</span> <span class="n">FixedPointCollection</span><span class="p">(</span>
            <span class="n">xstar</span><span class="o">=</span><span class="n">xstar</span><span class="p">,</span>
            <span class="n">x_init</span><span class="o">=</span><span class="n">initial_states</span><span class="p">,</span>
            <span class="n">inputs</span><span class="o">=</span><span class="n">inputs_bxd</span><span class="p">,</span>
            <span class="n">F_xstar</span><span class="o">=</span><span class="n">F_xstar</span><span class="p">,</span>
            <span class="n">qstar</span><span class="o">=</span><span class="n">ev_q_b</span><span class="p">,</span>
            <span class="n">dq</span><span class="o">=</span><span class="n">ev_dq_b</span><span class="p">,</span>
            <span class="n">n_iters</span><span class="o">=</span><span class="n">n_iters</span><span class="p">,</span>
            <span class="n">tol_unique</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tol_unique</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">np_dtype</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">fps</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_broadcast_nxd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tile_n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes in a tensor of shape [..., d] and reshapes to nxd</span>
<span class="sd">        tiles by tile_n if 1D</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Broadcast to [n, d]</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If only 1d, then tile</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="n">tile_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If &gt; 1d, then flatten up to last dim</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">end_dim</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Ensure proper device and dtype</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">torch_dtype</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="FixedPointFinder.get_jacobian">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.get_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around linearization object jacobian for current fixed points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linearization</span> <span class="o">=</span> <span class="n">Linearization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">linearization</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="FixedPointFinder.decompose_jacobian">
<a class="viewcode-back" href="../../../../mrnntorch.analysis.fixed_points.html#mrnntorch.analysis.fixed_points.fp_finder.FixedPointFinder.decompose_jacobian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decompose_jacobian</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper around linearization object decomposition for current fixed points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linearization</span> <span class="o">=</span> <span class="n">Linearization</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mrnn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">linearization</span><span class="o">.</span><span class="n">eigendecomposition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">mRNNTorch</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2026, John Lazzari.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>